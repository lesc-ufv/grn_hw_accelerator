#include <stdio.h>
// For the CUDA runtime routines (prefixed with "cuda_")
#include <cuda_runtime.h>

#define NUM_STATES (1<<20)
#define NUM_COPYS  (1 << 10)
#define NUM_NOS REPLACE_NUM_NODES

typedef unsigned int uint32_t;

using namespace std; 

__device__
bool state_comp(bool *s0, bool *s1, int size){
   for(int i = 0; i < size; i++){
       if(s0[i] != s1[i])return false;
   }
   return true;
}

__device__
void pass(bool *aux){
  
  bool vet[NUM_NOS];
  for(int i = 0; i < NUM_NOS; i++){
       vet[i] = aux[i];
  }
  REPLACE_ASSIGN_CODE
}

__global__
void findAttractor(bool *attractors, uint32_t * transients, uint32_t *periods, uint32_t numThreads){
   const int numNos = NUM_NOS;
   const int numState = NUM_STATES;
   const int numCopys = NUM_COPYS;
   unsigned int periodo, transient;
   bool S0[numNos];
   bool S1[numNos];
   uint32_t thread = blockDim.x * blockIdx.x + threadIdx.x;
   uint32_t step =  numState / numCopys; 
   uint32_t rest =  numState % numCopys;
   uint32_t begin = 0;
   uint32_t end = step - 1;
   bool flag = true;
   if(thread < numThreads){
       if(rest > 0){
           end = end + 1;
           rest = rest - 1;
       }else{
           flag = false;
       }
       
       for(uint32_t i = 0; i < numCopys;i++){
         if(i == thread) break;
         if(rest > 0){
           end = end + 1;
           begin = begin + 1;
           rest = rest - 1;
         }
         else if(rest == 0 && flag){
           begin = begin + 1;
           flag = 0;
         }
         begin += step;
         end += step;
       }
       //printf("Thread %d: begin:%d end: %d numStates: %d\n",thread,begin,end,end-begin+1);
       for(uint32_t  i = begin; i <= end; i++){
          int aux = i;
          for(int k = 0; k < numNos; k++){
              S0[k] = aux & 1 != 0;
              S1[k] = aux & 1 != 0;
	      aux >>= 1;
          }
          periodo = 0;
          transient = 0;
          do{
             pass(S0);
             pass(S1);
             pass(S1);
             transient++;
          }while (state_comp(S0,S1,numNos));
          do{
             pass(S0);
             periodo++;
          }while(state_comp(S0,S1,numNos));
          periodo--;
	  
          transients[i] = transient;
          periods[i]= periodo;
          for(int s = 0; s < numNos; s++){
            attractors[i*numNos + s] = S0[s];
	  }
       }
   }
}


int getIndice(int num_col, int i, int j)
{
    return (i*num_col)+ j;
}

/**
 * Host main routine
 */
int main(void)
{
    // Error code to check return values for CUDA calls
    cudaError_t err = cudaSuccess;

    // Print the vector length to be used, and compute its size
    size_t numNos = NUM_NOS;
    size_t numState = NUM_STATES;
    size_t size = numNos * numState * sizeof(bool);
    size_t size_transients = numState*sizeof(uint32_t);
    size_t size_periods = numState*sizeof(uint32_t);
    size_t totalBytes = size+size_transients+size_periods;
    size_t kb = totalBytes/(1024);
    size_t mb = kb/(1024);
    size_t gb = mb/(1024);
    printf("Find attractors net %lu nodes in %lu initials states.\n", numNos,numState);
    printf("Memory usage: %lu Gb or %lu Mb or %lu Kb.\n",gb,mb,kb);
    uint32_t *h_transients = (uint32_t*)malloc(size_transients);
    // Verify that allocations succeeded
    if (h_transients == NULL)
    {
        fprintf(stderr, "Failed to allocate h_transients!\n");
        exit(EXIT_FAILURE);
    }    
    uint32_t *h_periods = (uint32_t*)malloc(size_periods);
    // Verify that allocations succeeded
    if (h_periods == NULL)
    {
        fprintf(stderr, "Failed to allocate h_periods!\n");
        exit(EXIT_FAILURE);
    }
    // Allocate the host output vector C
    bool *h_attractors = (bool *)malloc(size);

    // Verify that allocations succeeded
    if (h_attractors == NULL)
    {
        fprintf(stderr, "Failed to allocate h_attractors!\n");
        exit(EXIT_FAILURE);
    }
    // Allocate the device vectors
    uint32_t *d_transients = NULL;
    err = cudaMalloc((void **)&d_transients, NUM_STATES*sizeof(uint32_t));

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to allocate d_transients (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    uint32_t *d_periods = NULL;
    err = cudaMalloc((void **)&d_periods, NUM_STATES*sizeof(uint32_t));

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to allocate d_periods (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    
    bool *d_attractors = NULL;
    err = cudaMalloc((void **)&d_attractors, size);

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to allocate d_attractors (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }

    // Launch the Vector Add CUDA Kernel
    uint32_t threadsPerBlock = 256;
    uint32_t blocksPerGrid =(NUM_COPYS + threadsPerBlock - 1) / threadsPerBlock;
    printf("CUDA kernel launch with %d blocks of %d threads\n", blocksPerGrid, threadsPerBlock);
    
    findAttractor<<<blocksPerGrid, threadsPerBlock>>>(d_attractors,d_transients,d_periods,NUM_COPYS);
    
    err = cudaGetLastError();
    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to launch findAttractor kernel (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }

    // Copy the device result vector in device memory to the host result vector
    // in host memory.
    printf("Copy output data from the CUDA device to the host memory\n");
    err = cudaMemcpy(h_transients, d_transients,size_transients, cudaMemcpyDeviceToHost);
    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to copy vector d_transients from device to host (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    
        err = cudaMemcpy(h_periods, d_periods, size_periods, cudaMemcpyDeviceToHost);
    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to copy vector d_periods from device to host (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    err = cudaMemcpy(h_attractors, d_attractors, size, cudaMemcpyDeviceToHost);
    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to copy vector d_attractors from device to host (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    /*
    printf("Attractor found:\n");
    for(int i = 0; i < numState; i++){
       for(int j = 0; j < numNos; j++){
          printf("%d",h_attractors[getIndice(numNos,i,j)]);
      }
      printf("\n");
    }
    printf("\n");
    */
    err = cudaFree(d_transients);

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to free device vector d_transients (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    err = cudaFree(d_periods);

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to free device vector d_periods (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    err = cudaFree(d_attractors);

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to free device vector d_attractors (error code %s)!\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }

    // Free host memory
    free(h_transients);
    free(h_periods);
    free(h_attractors);

    // Reset the device and exit
    // cudaDeviceReset causes the driver to clean up all state. While
    // not mandatory in normal operation, it is good practice.  It is also
    // needed to ensure correct operation when the application is being
    // profiled. Calling cudaDeviceReset causes all profile data to be
    // flushed before the application exits
    err = cudaDeviceReset();

    if (err != cudaSuccess)
    {
        fprintf(stderr, "Failed to deinitialize the device! error=%s\n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }

    printf("Done\n");
    return 0;
}





